\documentclass[12pt]{article}
\usepackage[breaklinks=true]{hyperref}
\usepackage{color}
\usepackage{amsmath,amssymb,amsthm}
\usepackage{natbib}
\usepackage[margin=0.75in]{geometry}
\usepackage[singlespacing]{setspace}
\usepackage[bottom]{footmisc}
\usepackage{floatrow}
\usepackage{float,graphicx}
\usepackage{enumerate}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{assumption}{Assumption}

\newcommand{\beq}{\begin{equation}}
\newcommand{\eeq}{\end{equation}}


\newcommand{\todo}[1]{{\color{red}{TO DO: \sc #1}}}

\newcommand{\reals}{\mathbb{R}}
\newcommand{\integers}{\mathbb{Z}}
\newcommand{\naturals}{\mathbb{N}}
\newcommand{\rationals}{\mathbb{Q}}

\newcommand{\ind}{\mathbb{I}} % Indicator function
\newcommand{\pr}{\mathbb{P}} % Generic probability
\newcommand{\ex}{\mathbb{E}} % Generic expectation
\newcommand{\var}{\textrm{Var}}
\newcommand{\cov}{\textrm{Cov}}

\newcommand{\normal}{N} % for normal distribution 
\newcommand{\eps}{\varepsilon}
\newcommand\independent{\protect\mathpalette{\protect\independenT}{\perp}}
\def\independenT#1#2{\mathrel{\rlap{$#1#2$}\mkern2mu{#1#2}}}
\newcommand{\argmax}{\textrm{argmax}}
\newcommand{\argmin}{\textrm{argmin}}

\title{Outline: PRNGs and Permutations}
\author{Kellie Ottoboni}
\date{Draft \today}
\begin{document}
\maketitle

%\newpage

%\begin{abstract}


%\end{abstract}

%\newpage

\section{May 30, 2016: Thoughts on coding samples}

Suppose the $n$ elements of the population are in a canonical order.
There is a one-to-one map between strings of at most $n$ bits with exactly $k$ nonzero bits
and samples of size $k$. 
Since $n$ and $k$ are known, we can suppose without loss of generality that $k \le n-k \le n/2$
(otherwise, code the elements omitted from the sample instead of the included elements).

Code a sample by listing bits up to the $k$th nonzero bit, not inclusive.
This completely determines the sample.
If the code contains $m$ bits, it specifies the first $k-1$ sampled elements, and then the $(m+1)$st element of the population is included in the sample.
Elements $m+2, \dots, n-1, n$ are not.
This is a \textbf{prefix code}: no complete code is the beginning of another code.

Using this coding, the total number of bits needed to specify all possible samples:
\begin{itemize}
\item there is  $1 = {{k-1} \choose {0}}$ sample that takes exactly $k-1$ bits to code, namely all $1$s
\item there are $k = {{k} \choose {1}}$ samples that take exactly $k$ bits: the samples only omit one of the first $k$ elements
\item there are ${{k+1} \choose 2} $ that take exactly $k+1$ bits
\item there are $ {{k+2} \choose 3} $ that take exactly $k+2$ bits
\item there are $ {{k+\ell-1} \choose {\ell}} $ that take exactly $k+\ell-1$ bits. Equivalently, there are ${{\ell} \choose {\ell - k + 1}}$ that take exactly $\ell$ bits.
\item there are $ {{n-2} \choose {n - k+1}} = {{n-2} \choose {k-1}} $ that take exactly $n-2$ bits
\item there are $ {{n-2} \choose {k-1}} $ samples that take exactly $n-1$ bits: they are exactly the $ {{n-2} \choose {k-1}} $ codes of length $n-2$ bits with an additional $0$ appended. They encode samples where the last element of the population is included.
\end{itemize}
Adding up all the ways to code samples, the number of bits for the entire code is
%$$ b = (n-1) + \sum_{\ell=k}^{n-1} \ell {{\ell-1} \choose {\ell-k}}. $$  (we should be able to simplify this)
$$ b = (n-1)  {{n-2} \choose {k-1}} + \sum_{\ell=k-1}^{n-2} \ell {{\ell} \choose {\ell-k+1}}.$$



Theoretical lower bound by Shannon entropy:

$$ H = \log_2 {{n} \choose {k}}.$$


\section{May 17, 2016}
\begin{itemize}
\item The first order of business is to investigate how R and Python generate pseudo-random numbers and
what algorithms they use to sample, permute, shuffle, etc.
This may require looking at the raw code since the R documentation doesn't say how \texttt{sample} works.
\begin{itemize}
\item There doesn't seem to be any way to see what \texttt{sample} does.
However, someone has implemented a C++ version for RcppArmadillo at \url{https://github.com/RcppCore/RcppArmadillo/blob/master/inst/include/RcppArmadilloExtensions/sample.h}.
The functions here permute in place by first randomly selecting \textit{indices} for the new sample, then copying the original data into the return vector using the new indices.
\begin{enumerate}
\item \texttt{SampleReplace} calls \texttt{unif\_rand()} and multiplies by the vector length.
\item \texttt{SampleNoReplace} creates a vector of the numbers $1, \dots, N$, chooses a random index from the list and puts that into the \texttt{index} vector, then replaces the sampled element with the last and removes the last element.
\item \texttt{ProbSampleReplace} does a sort in descending order of sampling probability. Then
\end{enumerate}
\end{itemize}
\item \textbf{Permutation testing with one sample:} \\
We have $N$ observations and we're doing some permutation test with them.
To approximate the null distribution, we want to sample uniformly at random from all $N!$ permutations of the observations.
Is it possible to obtain all of these permutations, or are we constrained by the period of the PRNG?
\begin{itemize}
\item I am totally open to changing notation! This is temporary.
\item Suppose the period of the PRNG is $\mathcal{P}$.
\item Suppose the permutation algorithm takes $K$ operations.
\item If $K \equiv 0 \mod \mathcal{P}$, then the PRNG will start over at some point. If $\mathcal{P}/K < N!$, then we can't reach all possible permutations.
Otherwise, we're in good shape and we will just start to repeat permutations before the PRNG reaches the end of its period.
\item What happens if $\mathcal{P}/K < N!$ but $K$ does not divide $\mathcal{P}$?
\end{itemize}
\item What is the ``best'' way to do permutations to avoid reaching the end of the period?
There are two issues at tension: the period of the PRNG and the computational complexity of the PRNG and shuffling algorithm.
We want to balance computational efficiency with correctness.
\item What happens if we generate pseudo-random numbers in a distributed fashion?
Obviously one has to set the seed differently for each thread, but does this improve the risk of repeating?
\end{itemize}

\bibliographystyle{plainnat}
\bibliography{refs}


\end{document}